using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using System.Threading.Tasks;

namespace CryptoLibrary
{


    public interface Iaes
    {
        void dataWrite(string Data, string key);
        void ReadData(string key);
    }


    public class StreamAes : Iaes
    {
        public void dataWrite(string Data, string key)
        {
            AESCrypto aes = new AESCrypto();
            using (FileStream fstream = new FileStream("data.txt", FileMode.OpenOrCreate))
            {
                byte[] array = System.Text.Encoding.Default.GetBytes(Data);
                fstream.Write(array, 0, array.Length);
                string TextFromFile = System.Text.Encoding.Default.GetString(array);
                aes.Encrypt(TextFromFile, key);

            }

        }

        public void ReadData(string key)
        {
            AESCrypto aes = new AESCrypto();
            FileStream fstream = new FileStream("data.txt", FileMode.Open);

            FileStream finout = new FileStream("decr.txt", FileMode.Create);

            byte[] array = new byte[fstream.Length];
            fstream.Read(array, 0, array.Length);

            string TextFromFile = System.Text.Encoding.Default.GetString(array);
            aes.Decrypt(TextFromFile, key);

            byte[] decr = System.Text.Encoding.Default.GetBytes(TextFromFile);
            finout.Write(decr, 0, decr.Length);
            string Textdecr = System.Text.Encoding.Default.GetString(decr);



            finout.Close();
            fstream.Close();

        }

    }



    public class AESCrypto
    {

        #region Variables
        List<byte[,]> Keys = new List<byte[,]>();
        byte[,] state;
        byte[] Rcon = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 };
        byte[,] SBOX = {
    {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},
    {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},
    {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},
    {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},
    {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},
    {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},
    {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},
    {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},
    {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},
    {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},
    {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},
    {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},
    {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},
    {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},
    {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},
    {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}};
        byte[,] InvSBOX = {
    {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb},
    {0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb},
    {0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e},
    {0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25},
    {0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92},
    {0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84},
    {0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06},
    {0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b},
    {0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73},
    {0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e},
    {0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b},
    {0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4},
    {0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f},
    {0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef},
    {0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61},
    {0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d}};
        #endregion

        private void AddRoundKey(byte[,] key)
        {
            for (int i = 0; i < 4; ++i)
                for (int j = 0; j < 4; ++j)
                    state[i, j] ^= key[i, j];

        }
        private void SubBytes()
        {
            byte row, column;
            for (int i = 0; i < 4; ++i)
                for (int j = 0; j < 4; ++j)
                {
                    column = (byte)(state[i, j] & 0x0F);
                    row = (byte)(state[i, j] & 0xF0);
                    row >>= 4;
                    state[i, j] = SBOX[row, column];
                }
        }
        private void ShiftRows()
        {
            byte temp;
            for (int i = 1; i < 4; ++i)
            {
                for (int j = 1; j <= i; ++j)
                    for (int c = 0; c < 3; ++c)
                    {
                        temp = state[i, c];
                        state[i, c] = state[i, c + 1];
                        state[i, c + 1] = temp;
                    }
            }
        }
        private void InvSubBytes()
        {
            byte row, column;
            for (int i = 0; i < 4; ++i)
                for (int j = 0; j < 4; ++j)
                {
                    column = (byte)(state[i, j] & 0x0F);
                    row = (byte)(state[i, j] & 0xF0);
                    row >>= 4;
                    state[i, j] = InvSBOX[row, column];
                }
        }
        private void InvShiftRows()
        {
            byte temp;
            for (int i = 1; i < 4; ++i)
            {
                for (int j = 1; j <= i; ++j)
                    for (int c = 3; c > 0; --c)
                    {
                        temp = state[i, c];
                        state[i, c] = state[i, c - 1];
                        state[i, c - 1] = temp;
                    }
            }
        }
        private void InvMixColumns()
        {
            byte[,] newstate = new byte[4, 4];
            byte[,] TM ={   
                {0x0E, 0x0B, 0x0D, 0x09},
                {0x09, 0x0E, 0x0B, 0x0D},
                {0x0D, 0x09, 0x0E, 0x0B},
                {0x0B, 0x0D, 0x09, 0x0E}
            };
            for (int i = 0; i < 4; ++i)
                for (int j = 0; j < 4; ++j)
                {
                    newstate[i, j] = (byte)(MultiplyunderGF(TM[i, 0], state[0, j]) ^ MultiplyunderGF(TM[i, 1], state[1, j])
                        ^ MultiplyunderGF(TM[i, 2], state[2, j]) ^ MultiplyunderGF(TM[i, 3], state[3, j]));
                }
            state = newstate;
        }
        private void MixColumns()
        {
            byte[,] newstate = new byte[4, 4];
            byte[,] TM ={   
                {0x02, 0x03, 0x01, 0x01},
                {0x01, 0x02, 0x03, 0x01},
                {0x01, 0x01, 0x02, 0x03},
                {0x03, 0x01, 0x01, 0x02}
            };
            for (int i = 0; i < 4; ++i)
                for (int j = 0; j < 4; ++j)
                {
                    newstate[i, j] = (byte)(MultiplyunderGF(TM[i, 0], state[0, j]) ^ MultiplyunderGF(TM[i, 1], state[1, j])
                        ^ MultiplyunderGF(TM[i, 2], state[2, j]) ^ MultiplyunderGF(TM[i, 3], state[3, j]));
                }
            state = newstate;
        }
        private byte MultiplyunderGF(byte a, byte b)
        {
            short temp = b; bool[] SetBits = new bool[8];
            byte i = 0;
            while (temp != 0)
            {
                if ((temp & 1) == 1)
                    SetBits[i] = true;
                temp >>= 1;
                ++i;
            }
            byte[] ShiftedBytes = new byte[8];
            ShiftedBytes[0] = a;
            temp = a;
            for (int j = 1; j < i; ++j)
            {
                temp <<= 1;
                if ((0x0100 & temp) > 0)
                    temp ^= 0x011B;
                ShiftedBytes[j] = (byte)temp;
            }
            temp = 0;
            for (int j = 0; j < i; ++j)
            {
                if (SetBits[j] == true)
                    temp ^= ShiftedBytes[j];
            }
            return (byte)temp;
        }
        private byte[,] NextKey(int Round)
        {
            byte[,] newkey = new byte[4, 4]; byte column, row;

            newkey[0, 0] = Keys[Round - 1][1, 3];
            newkey[1, 0] = Keys[Round - 1][2, 3];
            newkey[2, 0] = Keys[Round - 1][3, 3];
            newkey[3, 0] = Keys[Round - 1][0, 3];


            for (int i = 0; i < 4; ++i)
            {
                column = (byte)(newkey[i, 0] & 0x0F);
                row = (byte)(newkey[i, 0] & 0xF0);
                row >>= 4;
                newkey[i, 0] = SBOX[row, column];
            }
            newkey[0, 0] ^= (byte)(Rcon[Round - 1] ^ Keys[Round - 1][0, 0]);
            for (int i = 1; i < 4; ++i)
                newkey[i, 0] ^= Keys[Round - 1][i, 0];

            for (int i = 1; i < 4; ++i)
                for (int j = 0; j < 4; ++j)
                    newkey[j, i] = (byte)(Keys[Round - 1][j, i] ^ newkey[j, i - 1]);


            return newkey;
        }
        private byte[,] ToByteArray(string s)
        {
            byte[,] ByteArray = new byte[4, 4];
            int i = 2;
            for (int j = 0; j < 4; ++j)
                for (int h = 0; h < 4; ++h)
                {
                    ByteArray[h, j] = Convert.ToByte(s.Substring(i, 2), 16);
                    i += 2;
                }
            return ByteArray;
        }
        public override String ToString()
        {
            string cipher = "0x", tmp;
            for (int i = 0; i < 4; ++i)
                for (int j = 0; j < 4; ++j)
                {
                    tmp = Convert.ToString(state[j, i], 16);
                    if (tmp.Length == 1)
                        cipher += "0";
                    cipher += tmp;
                }
            return cipher;
        }
        public String Decrypt(string cipherText, string key)
        {
            state = ToByteArray(cipherText);
            byte[,] Key = ToByteArray(key);
            Keys.Add(Key);
            for (int i = 1; i <= 10; ++i)
                Keys.Add(NextKey(i));
            AddRoundKey(Keys[10]);
            for (int i = 9; i >= 1; --i)
            {
                InvSubBytes();
                InvShiftRows();
                AddRoundKey(Keys[i]);
                InvMixColumns();
            }

            InvShiftRows();
            InvSubBytes();
            AddRoundKey(Keys[0]);
            return ToString();
        }
        public string Encrypt(string plainText, string key)
        {
            state = ToByteArray(plainText);
            byte[,] Key = ToByteArray(key);
            Keys.Add(Key);
            AddRoundKey(Key);
            for (int i = 1; i <= 9; ++i)
            {
                Key = NextKey(i);
                Keys.Add(Key);
                SubBytes();
                ShiftRows();
                MixColumns();
                AddRoundKey(Key);
            }
            Key = NextKey(10);
            Keys.Add(Key);
            SubBytes();
            ShiftRows();
            AddRoundKey(Key);

            return ToString();
        }


    }








































































































        //public interface AESInterface
        //{
        //    void EncryptStream(Stream input, Stream inpKey, Stream output);
        //   // void DecryptStream(Stream input, Stream inpKey, Stream output);
        //}

        //public class CypherAES : AESInterface
        //{
        //    public void EncryptStream(Stream input, Stream inpKey, Stream output)
        //    {
        //        AES aes = new AES();
        //        aes.EncryptStream(input, inpKey, output);
        //    }

        //    //public void DecryptStream(Stream input, Stream inpKey, Stream output)
        //    //{
        //    //    AES aes = new AES();
        //    //    aes.DecryptStream(input, inpKey, output);
        //    //}
        //}

        ////public interface Iaes
        ////{
        ////    void dataWrite(string Data, string key);
        ////    void ReadData(string key);
        ////}


        ////public class StreamAes : Iaes
        ////{
        ////    public void dataWrite(string Data, string key)
        ////    {
        ////        AESCrypto aes = new AESCrypto();
        ////        using (FileStream fstream = new FileStream("data.txt", FileMode.OpenOrCreate))
        ////        {
        ////            byte[] array = System.Text.Encoding.Default.GetBytes(Data);
        ////            fstream.Write(array, 0, array.Length);
        ////            string TextFromFile = System.Text.Encoding.Default.GetString(array);
        ////            aes.Encrypt(TextFromFile, key);

        ////        }

        ////    }

        ////    public void ReadData(string key)
        ////    {
        ////        AESCrypto aes = new AESCrypto();
        ////        FileStream fstream = new FileStream("data.txt", FileMode.Open);

        ////        FileStream finout = new FileStream("decr.txt", FileMode.Create);

        ////        byte[] array = new byte[fstream.Length];
        ////        fstream.Read(array, 0, array.Length);  

        ////        string TextFromFile = System.Text.Encoding.Default.GetString(array);
        ////        aes.Decrypt(TextFromFile, key); 

        ////        byte[] decr = System.Text.Encoding.Default.GetBytes(TextFromFile);
        ////        finout.Write(decr, 0, decr.Length);
        ////        string Textdecr = System.Text.Encoding.Default.GetString(decr);



        ////        finout.Close();
        ////        fstream.Close();

        ////    }

        ////}



        //public class AES
        //{

        ////    #region Variables
        ////    List<byte[,]> Keys = new List<byte[,]>();
        ////    byte[,] state;
        ////    byte[] Rcon = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 };
        ////    byte[,] SBOX = {
        ////{0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},
        ////{0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},
        ////{0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},
        ////{0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},
        ////{0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},
        ////{0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},
        ////{0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},
        ////{0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},
        ////{0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},
        ////{0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},
        ////{0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},
        ////{0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},
        ////{0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},
        ////{0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},
        ////{0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},
        ////{0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}};
        ////    byte[,] InvSBOX = {
        ////{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb},
        ////{0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb},
        ////{0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e},
        ////{0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25},
        ////{0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92},
        ////{0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84},
        ////{0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06},
        ////{0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b},
        ////{0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73},
        ////{0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e},
        ////{0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b},
        ////{0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4},
        ////{0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f},
        ////{0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef},
        ////{0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61},
        ////{0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d}};
        ////    #endregion

        ////    private void AddRoundKey(byte[,] key)
        ////    {
        ////        for (int i = 0; i < 4; ++i)
        ////            for (int j = 0; j < 4; ++j)
        ////                state[i, j] ^= key[i, j];

        ////    }
        ////    private void SubBytes()
        ////    {
        ////        byte row, column;
        ////        for (int i = 0; i < 4; ++i)
        ////            for (int j = 0; j < 4; ++j)
        ////            {
        ////                column = (byte)(state[i, j] & 0x0F);
        ////                row = (byte)(state[i, j] & 0xF0);
        ////                row >>= 4;
        ////                state[i, j] = SBOX[row, column];
        ////            }
        ////    }
        ////    private void ShiftRows()
        ////    {
        ////        byte temp;
        ////        for (int i = 1; i < 4; ++i)
        ////        {
        ////            for (int j = 1; j <= i; ++j)
        ////                for (int c = 0; c < 3; ++c)
        ////                {
        ////                    temp = state[i, c];
        ////                    state[i, c] = state[i, c + 1];
        ////                    state[i, c + 1] = temp;
        ////                }
        ////        }
        ////    }
        ////    private void InvSubBytes()
        ////    {
        ////        byte row, column;
        ////        for (int i = 0; i < 4; ++i)
        ////            for (int j = 0; j < 4; ++j)
        ////            {
        ////                column = (byte)(state[i, j] & 0x0F);
        ////                row = (byte)(state[i, j] & 0xF0);
        ////                row >>= 4;
        ////                state[i, j] = InvSBOX[row, column];
        ////            }
        ////    }
        ////    private void InvShiftRows()
        ////    {
        ////        byte temp;
        ////        for (int i = 1; i < 4; ++i)
        ////        {
        ////            for (int j = 1; j <= i; ++j)
        ////                for (int c = 3; c > 0; --c)
        ////                {
        ////                    temp = state[i, c];
        ////                    state[i, c] = state[i, c - 1];
        ////                    state[i, c - 1] = temp;
        ////                }
        ////        }
        ////    }
        ////    private void InvMixColumns()
        ////    {
        ////        byte[,] newstate = new byte[4, 4];
        ////        byte[,] TM ={   
        ////            {0x0E, 0x0B, 0x0D, 0x09},
        ////            {0x09, 0x0E, 0x0B, 0x0D},
        ////            {0x0D, 0x09, 0x0E, 0x0B},
        ////            {0x0B, 0x0D, 0x09, 0x0E}
        ////        };
        ////        for (int i = 0; i < 4; ++i)
        ////            for (int j = 0; j < 4; ++j)
        ////            {
        ////                newstate[i, j] = (byte)(MultiplyunderGF(TM[i, 0], state[0, j]) ^ MultiplyunderGF(TM[i, 1], state[1, j])
        ////                    ^ MultiplyunderGF(TM[i, 2], state[2, j]) ^ MultiplyunderGF(TM[i, 3], state[3, j]));
        ////            }
        ////        state = newstate;
        ////    }
        ////    private void MixColumns()
        ////    {
        ////        byte[,] newstate = new byte[4, 4];
        ////        byte[,] TM ={   
        ////            {0x02, 0x03, 0x01, 0x01},
        ////            {0x01, 0x02, 0x03, 0x01},
        ////            {0x01, 0x01, 0x02, 0x03},
        ////            {0x03, 0x01, 0x01, 0x02}
        ////        };
        ////        for (int i = 0; i < 4; ++i)
        ////            for (int j = 0; j < 4; ++j)
        ////            {
        ////                newstate[i, j] = (byte)(MultiplyunderGF(TM[i, 0], state[0, j]) ^ MultiplyunderGF(TM[i, 1], state[1, j])
        ////                    ^ MultiplyunderGF(TM[i, 2], state[2, j]) ^ MultiplyunderGF(TM[i, 3], state[3, j]));
        ////            }
        ////        state = newstate;
        ////    }
        ////    private byte MultiplyunderGF(byte a, byte b)
        ////    {
        ////        short temp = b; bool[] SetBits = new bool[8];
        ////        byte i = 0;
        ////        while (temp != 0)
        ////        {
        ////            if ((temp & 1) == 1)
        ////                SetBits[i] = true;
        ////            temp >>= 1;
        ////            ++i;
        ////        }
        ////        byte[] ShiftedBytes = new byte[8];
        ////        ShiftedBytes[0] = a;
        ////        temp = a;
        ////        for (int j = 1; j < i; ++j)
        ////        {
        ////            temp <<= 1;
        ////            if ((0x0100 & temp) > 0)
        ////                temp ^= 0x011B;
        ////            ShiftedBytes[j] = (byte)temp;
        ////        }
        ////        temp = 0;
        ////        for (int j = 0; j < i; ++j)
        ////        {
        ////            if (SetBits[j] == true)
        ////                temp ^= ShiftedBytes[j];
        ////        }
        ////        return (byte)temp;
        ////    }
        ////    private byte[,] NextKey(int Round)
        ////    {
        ////        byte[,] newkey = new byte[4, 4]; byte column, row;

        ////        newkey[0, 0] = Keys[Round - 1][1, 3];
        ////        newkey[1, 0] = Keys[Round - 1][2, 3];
        ////        newkey[2, 0] = Keys[Round - 1][3, 3];
        ////        newkey[3, 0] = Keys[Round - 1][0, 3];


        ////        for (int i = 0; i < 4; ++i)
        ////        {
        ////            column = (byte)(newkey[i, 0] & 0x0F);
        ////            row = (byte)(newkey[i, 0] & 0xF0);
        ////            row >>= 4;
        ////            newkey[i, 0] = SBOX[row, column];
        ////        }
        ////        newkey[0, 0] ^= (byte)(Rcon[Round - 1] ^ Keys[Round - 1][0, 0]);
        ////        for (int i = 1; i < 4; ++i)
        ////            newkey[i, 0] ^= Keys[Round - 1][i, 0];

        ////        for (int i = 1; i < 4; ++i)   
        ////            for (int j = 0; j < 4; ++j)      
        ////                newkey[j, i] = (byte)(Keys[Round - 1][j, i] ^ newkey[j, i - 1]);


        ////        return newkey;
        ////    }
        ////    private byte[,] ToByteArray(string s)
        ////    {
        ////        byte[,] ByteArray = new byte[4, 4];
        ////        int i = 2;
        ////        for (int j = 0; j < 4; ++j)
        ////            for (int h = 0; h < 4; ++h)
        ////            {
        ////                ByteArray[h, j] = Convert.ToByte(s.Substring(i, 2), 16);
        ////                i += 2;
        ////            }
        ////        return ByteArray;
        ////    }
        ////    public override String ToString()
        ////    {
        ////        string cipher = "0x", tmp;       
        ////        for (int i = 0; i < 4; ++i)
        ////            for (int j = 0; j < 4; ++j) 
        ////            {
        ////                tmp = Convert.ToString(state[j, i], 16);
        ////                if (tmp.Length == 1) 
        ////                    cipher += "0";
        ////                cipher += tmp;
        ////            }
        ////        return cipher;
        ////    }
        //    //public String Decrypt(string cipherText, string key)
        //    //public void DecryptStream(Stream input, Stream inpKey, Stream output)
        //    //{
        //    //    state = ToByteArray(cipherText);
        //    //    byte[,] Key = ToByteArray(key);
        //    //    Keys.Add(Key);
        //    //    for (int i = 1; i <= 10; ++i)
        //    //        Keys.Add(NextKey(i));
        //    //    AddRoundKey(Keys[10]);
        //    //    for (int i = 9; i >= 1; --i)  
        //    //    {
        //    //        InvSubBytes();
        //    //        InvShiftRows();
        //    //        AddRoundKey(Keys[i]);
        //    //        InvMixColumns();
        //    //    }

        //    //    InvShiftRows();
        //    //    InvSubBytes();
        //    //    AddRoundKey(Keys[0]);
        //    //    return ToString();
        //    //}
        //    //public string Encrypt(string plainText, string key)






        //    // Here are all the lookup tables for the row shifts, rcon, s-boxes, and galois field multiplications
        //    static byte[] shift_rows_table = { 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11 };
        //    static byte[] shift_rows_table_inv = { 0, 13, 10, 7, 4, 1, 14, 11, 8, 5, 2, 15, 12, 9, 6, 3 };
        //    static byte[] lookup_rcon = { 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a };
        //    static byte[] lookup_sbox = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
        //    static byte[] lookup_sbox_inv = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
        //    static byte[] lookup_g2 = { 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65, 0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5 };
        //    static byte[] lookup_g3 = { 0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71, 0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41, 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1, 0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1, 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a, 0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba, 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda, 0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a, 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a, 0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a };
        //    static byte[] lookup_g9 = { 0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77, 0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7, 0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c, 0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc, 0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01, 0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91, 0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a, 0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b, 0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b, 0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30, 0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed, 0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6, 0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46 };
        //    static byte[] lookup_g11 = { 0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69, 0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9, 0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12, 0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2, 0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f, 0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f, 0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4, 0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e, 0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e, 0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55, 0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68, 0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13, 0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3 };
        //    static byte[] lookup_g13 = { 0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b, 0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b, 0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0, 0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20, 0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26, 0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6, 0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d, 0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91, 0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41, 0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa, 0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc, 0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47, 0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97 };
        //    static byte[] lookup_g14 = { 0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a, 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba, 0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81, 0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61, 0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17, 0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c, 0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b, 0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb, 0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20, 0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6, 0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d, 0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d };

        //    /// <summary>
        //    /// Apply and reverse the rijndael s-box to all elements in an array
        //    /// http://en.wikipedia.org/wiki/Rijndael_S-box
        //    /// </summary>
        //    static void SubBytes(byte[] a)
        //    {
        //        for (int i = 0; i < a.Length; i++)
        //            a[i] = lookup_sbox[a[i]];
        //    }
        //    static void SubBytesInv(byte[] a)
        //    {
        //        for (int i = 0; i < a.Length; i++)
        //            a[i] = lookup_sbox_inv[a[i]];
        //    }

        //    /// <summary>
        //    /// Perform the core key schedule transform on 4 bytes, as part of the key expansion process
        //    /// </summary>
        //    static void KeyScheduleCore(byte[] a, int i)
        //    {
        //        byte temp = a[0]; // Rotate the output eight bits to the left
        //        a[0] = a[1];
        //        a[1] = a[2];
        //        a[2] = a[3];
        //        a[3] = temp;
        //        SubBytes(a);      // Apply Rijndael's S-box on all four individual bytes in the output word
        //        a[0] ^= lookup_rcon[i]; // On just the first (leftmost) byte of the output word, perform the rcon operation with i
        //        // as the input, and exclusive or the rcon output with the first byte of the output word
        //    }

        //    /// <summary>
        //    /// Xor's the elements in A, by B, starting at the given offset in B
        //    /// </summary>
        //    static void Xor(byte[] a, List<byte> b, int offB)
        //    {
        //        for (int i = 0; i < a.Length; i++)
        //            a[i] ^= b[offB + i];
        //    }

        //    /// <summary>
        //    /// Expand the 128-bit key to 11 round keys
        //    /// http://en.wikipedia.org/wiki/Rijndael_key_schedule#The_key_schedule
        //    /// </summary>
        //    static byte[] Expand(byte[] key)
        //    {
        //        List<byte> keys = new List<byte>();
        //        keys.AddRange(key);       // The first 16 bytes of the expanded key are simply the encryption key
        //        int i = 1;                  // The rcon iteration value i is set to 1
        //        byte[] t = new byte[4];     // Temporary working area known as 't' in the Wiki article
        //        while (keys.Count < 176)
        //        {  // Until we have 176 bytes of expanded key, we do the following:
        //            keys.CopyTo(keys.Count - 4, t, 0, 4); // We assign the value of the previous four bytes in the expanded key to t
        //            KeyScheduleCore(t, i);                // We perform the key schedule core on t, with i as the rcon iteration value
        //            i++;                                  // We increment i by 1
        //            Xor(t, keys, keys.Count - 16);            // We exclusive-or t with the four-byte block 16 bytes before the new expanded key. 
        //            keys.AddRange(t);                     // This becomes the next 4 bytes in the expanded key

        //            // We then do the following three times to create the next twelve bytes
        //            for (int j = 0; j < 3; j++)
        //            {
        //                keys.CopyTo(keys.Count - 4, t, 0, 4); // We assign the value of the previous four bytes in the expanded key to t
        //                Xor(t, keys, keys.Count - 16);            // We exclusive-or t with the four-byte block 16 bytes before the new expanded key. 
        //                keys.AddRange(t);                     // This becomes the next 4 bytes in the expanded key
        //            }
        //        }
        //        return keys.ToArray();
        //    }

        //    /// <summary>
        //    /// Xor the current cipher state by a specific round key
        //    /// </summary>
        //    static void XorRoundKey(byte[] state, byte[] keys, int round)
        //    {
        //        for (int i = 0; i < 16; i++)
        //        {
        //            state[i] ^= keys[i + round * 16];
        //        }
        //    }

        //    /// <summary>
        //    /// Apply the shift rows step on the 16 byte cipher state
        //    /// http://en.wikipedia.org/wiki/Advanced_Encryption_Standard#The_ShiftRows_step
        //    /// </summary>
        //    static void ShiftRows(byte[] state)
        //    {
        //        byte[] temp = new byte[16];
        //        Array.Copy(state, temp, 16);
        //        for (int i = 0; i < 16; i++)
        //            state[i] = temp[shift_rows_table[i]];
        //    }

        //    /// <summary>
        //    /// Reverse the shift rows step on the 16 byte cipher state
        //    /// </summary>
        //    static void ShiftRowsInv(byte[] state)
        //    {
        //        byte[] temp = new byte[16];
        //        Array.Copy(state, temp, 16);
        //        for (int i = 0; i < 16; i++)
        //            state[i] = temp[shift_rows_table_inv[i]];
        //    }

        //    /// <summary>
        //    /// Perform the mix columns matrix on one column of 4 bytes
        //    /// http://en.wikipedia.org/wiki/Rijndael_mix_columns
        //    /// </summary>
        //    static void MixCol(byte[] state, int off)
        //    {
        //        byte a0 = state[off + 0];
        //        byte a1 = state[off + 1];
        //        byte a2 = state[off + 2];
        //        byte a3 = state[off + 3];
        //        state[off + 0] = (byte)(lookup_g2[a0] ^ lookup_g3[a1] ^ a2 ^ a3);
        //        state[off + 1] = (byte)(lookup_g2[a1] ^ lookup_g3[a2] ^ a3 ^ a0);
        //        state[off + 2] = (byte)(lookup_g2[a2] ^ lookup_g3[a3] ^ a0 ^ a1);
        //        state[off + 3] = (byte)(lookup_g2[a3] ^ lookup_g3[a0] ^ a1 ^ a2);
        //    }

        //    /// <summary>
        //    /// Perform the inverse mix columns matrix on one column of 4 bytes
        //    /// </summary>
        //    static void MixColInv(byte[] state, int off)
        //    {
        //        byte a0 = state[off + 0];
        //        byte a1 = state[off + 1];
        //        byte a2 = state[off + 2];
        //        byte a3 = state[off + 3];
        //        state[off + 0] = (byte)(lookup_g14[a0] ^ lookup_g9[a3] ^ lookup_g13[a2] ^ lookup_g11[a1]);
        //        state[off + 1] = (byte)(lookup_g14[a1] ^ lookup_g9[a0] ^ lookup_g13[a3] ^ lookup_g11[a2]);
        //        state[off + 2] = (byte)(lookup_g14[a2] ^ lookup_g9[a1] ^ lookup_g13[a0] ^ lookup_g11[a3]);
        //        state[off + 3] = (byte)(lookup_g14[a3] ^ lookup_g9[a2] ^ lookup_g13[a1] ^ lookup_g11[a0]);
        //    }

        //    /// <summary>
        //    /// Perform the mix columns matrix on each column of the 16 bytes
        //    /// </summary>
        //    static void MixCols(byte[] state)
        //    {
        //        MixCol(state, 0);
        //        MixCol(state, 4);
        //        MixCol(state, 8);
        //        MixCol(state, 12);
        //    }

        //    /// <summary>
        //    /// Perform the reverse mix columns matrix on each column of the 16 bytes
        //    /// </summary>
        //    static void MixColsInv(byte[] state)
        //    {
        //        MixColInv(state, 0);
        //        MixColInv(state, 4);
        //        MixColInv(state, 8);
        //        MixColInv(state, 12);
        //    }

        //    public string EncryptStream(Stream input, Stream inpKey, Stream output)
        //    {
        //        byte[] key = new byte[inpKey.Length];
        //        inpKey.Read(key, 0, Convert.ToInt32(inpKey.Length));

        //        byte[] state = new byte[input.Length];
        //        inpKey.Read(key, 0, Convert.ToInt32(input.Length));

        //        //StreamReader reader = new StreamReader(input);
        //       // string data = reader.ReadToEnd(); 


        //        //string TextFromFile = System.Text.Encoding.Default.GetString(input);
        //        //string state = Encoding.Default.GetString(input.ToArray()).TrimEnd('\0')

        //        //// Key expansion
        //        byte[] keys = Expand(key);

        //        // First Round
        //        byte[] c = new byte[16];
        //        Array.Copy(state, c, 16);
        //        XorRoundKey(c, keys, 0);

        //        // Middle rounds
        //        for (int i = 0; i < 9; i++)
        //        {
        //            SubBytes(c);
        //            ShiftRows(c);
        //            MixCols(c);
        //            XorRoundKey(c, keys, i + 1);
        //        }

        //        // Final Round
        //        SubBytes(c);
        //        ShiftRows(c);
        //        XorRoundKey(c, keys, 10);

        //        string otv = BitConverter.ToString(c);

        //        return otv;


        //        //state = ToByteArray(plainText);
        //        //byte[,] Key = ToByteArray(inpKey);
        //        //Keys.Add(Key);
        //        //AddRoundKey(Key);
        //        //for (int i = 1; i <= 9; ++i)
        //        //{
        //        //    Key = NextKey(i);
        //        //    Keys.Add(Key);
        //        //    SubBytes();
        //        //    ShiftRows();
        //        //    MixColumns();
        //        //    AddRoundKey(Key);
        //        //}
        //        //Key = NextKey(10);
        //        //Keys.Add(Key);
        //        //SubBytes();
        //        //ShiftRows();
        //        //AddRoundKey(Key);

        //        //return ToString();
        //    }

        //}



        public interface ElGamalInterface
        {
            void EncryptStream(Stream input, Stream output);
            void DecryptStream(Stream input, Stream output);
        }

        public class CypherElGamal : ElGamalInterface
        {
            public void EncryptStream(Stream input, Stream output)
            {
                ElGamal elGamal = new ElGamal();
                elGamal.EncryptStream(input, output);
            }

            public void DecryptStream(Stream input, Stream output)
            {
                ElGamal elGamal = new ElGamal();
                elGamal.DecryptStream(input, output);
            }
        }

        public class ElGamal
        {
            static int p = 157;
            static int x = 10;
            static int g = 3;
            static int y;

            int Pow(int a, int b, int m)
            {
                int tmp = a;
                int sum = tmp;
                for (int i = 1; i < b; i++)
                {
                    for (int j = 1; j < a; j++)
                    {
                        sum += tmp;
                        if (sum >= m)
                        {
                            sum -= m;
                        }
                    }
                    tmp = sum;
                }
                return tmp;
            }

            int Mul(int a, int b, int m)
            {
                int sum = 0;
                for (int i = 0; i < b; i++)
                {
                    sum += a;
                    if (sum >= m)
                    {
                        sum -= m;
                    }
                }
                return sum;
            }

            public void EncryptStream(Stream input, Stream output)
            {
                Random random = new Random();
                byte byteToCrypt;

                y = Pow(g, x, p);

                input.Position = 0;
                for (; input.Position < input.Length; )
                {
                    byteToCrypt = (byte)input.ReadByte();

                    int k = random.Next() % (p - 2) + 1;
                    int left = Pow(g, k, p);
                    int right = Mul(Pow(y, k, p), byteToCrypt, p);

                    output.WriteByte((byte)left);
                    output.WriteByte((byte)right);
                }
            }

            public void DecryptStream(Stream input, Stream output)
            {
                byte left, right;
                byte[] bytesToDecrypt = new byte[2];

                input.Position = 0;
                for (; input.Position < input.Length; )
                {
                    input.Read(bytesToDecrypt, 0, 2);

                    left = bytesToDecrypt[0];
                    right = bytesToDecrypt[1];

                    int m = Mul(right, Pow(left, p - 1 - x, p), p);
                    output.WriteByte((byte)m);
                }
            }
        }




        public interface MD5Interface
        {
            void HashStream(Stream input, Stream output);
        }

        public class CypherMD5 : MD5Interface
        {
            public void HashStream(Stream input, Stream output)
            {
                MD5 md5 = new MD5();
                md5.HashStream(input, output);
            }
        }

        public static class Md5Extensions
        {
            public static uint RotateLeft(this uint val, int count)
            {
                return (val << count) | (val >> (32 - count));
            }

            public static uint RotateRight(this uint val, int count)
            {
                return (val >> count) | (val << (32 - count));
            }

            public static string ConvertToString(this byte[] byteArray)
            {
                return BitConverter.ToString(byteArray).Replace("-", "").ToLower();
            }

            public static byte[] ConvertToByteArray(this string s)
            {
                return Encoding.UTF8.GetBytes(s);
            }
        }

        public class Digest
        {

            #region Variables

            public uint A = 0x67452301;
            public uint B = 0xEFCDAB89;
            public uint C = 0x98BADCFE;
            public uint D = 0X10325476;

            private const uint ChunkSize = 16;

            #endregion

            private uint N(int i)
            {
                uint n = D;

                switch (i)
                {
                    case 0:
                        n = A;
                        break;
                    case 1:
                        n = B;
                        break;
                    case 2:
                        n = C;
                        break;
                }

                return n;
            }

            private void FlipIt(uint hold)
            {
                A = D;
                D = C;
                C = B;
                B = hold;
            }

            public void Process(uint[] buffer)
            {
                uint locA = A;
                uint locB = B;
                uint locC = C;
                uint locD = D;

                for (uint i = 0; i < 64; i++)
                {
                    uint range = i / ChunkSize;
                    uint p = 0;
                    uint index = i;
                    switch (range)
                    {
                        case 0:
                            p = (B & C) | (~B & D);
                            break;
                        case 1:
                            p = (B & D) | (C & ~D);
                            index = (index * 5 + 1) % ChunkSize;
                            break;
                        case 2:
                            p = B ^ C ^ D;
                            index = (index * 3 + 5) % ChunkSize;
                            break;
                        case 3:
                            p = C ^ (B | ~D);
                            index = (index * 7) % ChunkSize;
                            break;
                    }


                    FlipIt(B + (A + p + buffer[index] + MD5.T[i]).RotateLeft((int)MD5.Shift[(range * 4) | (i & 3)]));

                }

                A += locA;
                B += locB;
                C += locC;
                D += locD;
            }

            public byte[] GetHash()
            {
                byte[] hash = new byte[16];

                int count = 0;
                for (int i = 0; i < 4; i++)
                {
                    uint n = N(i);

                    for (int a = 0; a < 4; a++)
                    {
                        hash[count++] = (byte)n;
                        n /= (uint)(Math.Pow(2, 8));
                    }
                }

                return hash;
            }

        }

        public class Data
        {
            public byte[] DataArr { set; get; }
            public int BlockCount { set; get; }
            public int Size { set; get; }
            public byte[] Padding { set; get; }

            public Data(byte[] data)
            {
                DataArr = data;
                Size = data.Length;
                BlockCount = ((Size + 8) >> 6) + 1;
                int total = BlockCount << 6;

                Padding = new byte[total - Size];
                Padding[0] = 0x80;
                long msg = (Size * 8);
                for (int i = 0; i < 8; i++)
                {
                    Padding[Padding.Length - 8 + i] = (byte)msg;
                    msg /= 269;
                }
            }

        }

        public class MD5
        {

            #region Variables

            public static uint[] Shift = {
            7,12,17,22,
            5,9,14,20,
            4,11,16,23,
            6,10,15,21
          };

            public static uint[] T = {
                0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,
                0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
                0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,
                0x6b901122,0xfd987193,0xa679438e,0x49b40821,
                0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,
                0xd62f105d,0x2441453,0xd8a1e681,0xe7d3fbc8,
                0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,
                0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
                0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,
                0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
                0x289b7ec6,0xeaa127fa,0xd4ef3085,0x4881d05,
                0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
                0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,
                0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
                0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,
                0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391
          };

            #endregion

            public void HashStream(Stream input, Stream output)
            {
                byte[] buf = new byte[input.Length];
                input.Read(buf, 0, (int)input.Length);

                byte[] result = Process(buf);

                output.Write(result, 0, result.Length);

                if (output.Position != 0)
                {
                    output.Position = 0;
                }
            }

            public byte[] Process(byte[] data)
            {
                Data d = new Data(data);

                Digest digest = new Digest();

                uint[] buffer = new uint[16];

                for (int i = 0; i < d.BlockCount; i++)
                {
                    int index = i * 64;

                    for (int a = 0; a < 64; a++, index++)
                    {
                        int bufferIndex = (a / 4);
                        buffer[bufferIndex] = ((uint)((index < d.Size) ? d.DataArr[index] : d.Padding[index - d.Size]) << 24) | (buffer[(bufferIndex)] >> 8);
                    }

                    digest.Process(buffer);

                }

                return digest.GetHash();

            }
        }

    }